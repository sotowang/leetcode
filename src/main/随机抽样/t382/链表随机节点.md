# [链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)

给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点**被选的概率一样**。

**进阶:**
如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？

**示例:**

```
// 初始化一个单链表 [1,2,3].
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
Solution solution = new Solution(head);

// getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。
solution.getRandom();
```

---

* [蓄水池采样算法](https://www.cnblogs.com/snowInPluto/p/5996269.html)
  * 既然说到采样问题，最重要的就是做到公平，也就是保证每个元素被采样到的概率是相同的。所以可以想到要想实现这样的算法，就需要掷骰子，也就是随机数算法。（这里就不具体讨论随机数算法了，假定我们有了一套很成熟的随机数算法了）
  * 对于第一个问题，还是比较简单，通过算法生成 [0,100000−1)[0,100000−1) 间的随机数 1000 个，并且保证不重复即可。再取出对应的元素即可。
  * 但是对于第二和第三个问题，就有些不同了，**我们不知道数据的整体规模有多大**。可能有人会想到，我可以先对数据进行一次遍历，计算出数据的数量 N，然后再按照上述的方法进行采样即可。这当然可以，但是并不好，毕竟这可能需要花上很多时间。也可以尝试估算数据的规模，但是这样得到的采样数据分布可能并不平均。

* 算法过程

  * 假设数据序列的规模为 `n`，需要采样的数量的为 `k`。

    首先构建一个可容纳 `k` 个元素的数组，将序列的前 `k `个元素放入数组中。

    然后从第 `k` 个元素开始，以 `k/n` 的概率来决定该元素是否被替换到数组中（数组中的元素被替换的概率是相同的）。 当遍历完所有元素之后，数组中剩下的元素即为所需采取的样本
    
https://leetcode-cn.com/problems/linked-list-random-node/solution/zhong-ju-si-wei-by-li-zi-he/