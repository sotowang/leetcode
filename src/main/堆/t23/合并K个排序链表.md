# [合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

**示例**:

```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```

---

 https://leetcode-cn.com/problems/merge-k-sorted-lists/addTwoNumbers/tan-xin-suan-fa-you-xian-dui-lie-fen-zhi-fa-python/ 

**思路分析**：

1、由于是 `k` 个排序链表，那么这` k` 个排序的链表头结点中 `val` 最小的结点就是合并以后的链表中最小的结点；

2、最小结点所在的链表的头结点就要更新了，更新成最小结点的下一个结点（如果有的话），此时还是这 `k` 个链表，这 `k` 个排序的链表头结点中 `val` 最小的结点就是合并以后的链表中第 22 小的结点。

写到这里，我想你应该差不多明白了，我们每一次都从这 `k` 个排序的链表头结点中拿出 val 最小的结点“穿针引线”成新的链表，这个链表就是题目要求的“合并后的排序链表”。“局部最优，全局就最优”，这不就是贪心算法的思想吗。

这里我们举生活中的例子来理解这个思路。

> 假设你是一名体育老师，有 33 个班的学生，他们已经按照身高从矮到高排好成了 33 列纵队，现在要把这 33 个班的学生也按照身高从矮到高排列 11 列纵队。我们可以这么做：
>
> 1、让 33 个班的学生按列站在你的面前，这时你能看到站在队首的学生的全身；
> 2、每一次队首的 33 名同学，请最矮的同学出列到“队伍4”（即我们最终认为排好序的队列），出列的这一列的后面的所有同学都向前走一步（其实走不走都行，只要你能比较出站在你面前的 3 位在队首的同学同学的高矮即可）；
> 3、重复第 2 步，直到 33 个班的同学全部出列完毕。

具体实现的时候，“每一次队首的 33 名同学，请最矮的同学出列”这件事情可以交给优先队列（最小堆、最小索引堆均可）去完成。在连续的两次出队之间完成“穿针引线”的工作。

**复杂度分析**：

* 时间复杂度：`O(Nlogk)`，这里 `N` 是这 `k` 个链表的结点总数，每一次从一个优先队列中选出一个最小结点的时间复杂度是 `O(logk)`，故时间复杂度为 `O(Nlogk)`。
* 空间复杂度：`O(k)`，使用优先队列需要 `k` 个空间，“穿针引线”需要常数个空间，因此空间复杂度为 `O(k)`。

