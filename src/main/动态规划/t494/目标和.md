# [目标和](https://leetcode-cn.com/problems/target-sum/)

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 `+` 和 `-`。对于数组中的任意一个整数，你都可以从 `+` 或 `-`中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

**示例 1:**

```
输入: nums: [1, 1, 1, 1, 1], S: 3
输出: 5
解释: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
```

**注意:**

1. 数组非空，且长度不会超过20。
2. 初始的数组的和不会超过1000。
3. 保证返回的最终结果能被32位整数存下。

---

https://leetcode-cn.com/problems/target-sum/solution/python-dfs-xiang-jie-by-jimmy00745/

**方法是**

开辟一个长度为P+1的数组，命名为`dp`

`dp`的第x项，代表组合成数字x有多少方法。比如说,`dp[0] = 1`，代表组合成0只有1中方法，即什么也不取。比如说`dp[5] = 3` ，代表使总和加到5总共有三种方法。

所以最后返回的就是`dp[P]`，代表组合成P的方法有多少种

**问题是**

怎么更新`dp`数组呢？

遍历`nums`，遍历的数记作`num`

再逆序遍历从`P`到`num`，遍历的数记作j

更新`dp[j] = dp[j - num] + dp[j]`

这样遍历的含义是，对每一个在`nums`数组中的数`num`而言，`dp`在从`num`到`P`的这些区间里，都可以加上一个`num`，来到达想要达成的P。

举例来说，对于数组`[1,2,3,4,5]`，想要康康几种方法能组合成4,那么设置`dp[0]`到`dp[4]`的数组

假如选择了数字2,那么`dp[2:5]`（也就是2到4）都可以通过加上数字2有所改变，而`dp[0:2]`（也就是0到1）加上这个2很明显就超了，就不管它。

以前没有考虑过数字2,考虑了会怎么样呢？就要更新`dp[2:5]`，比如说当我们在更新`dp[3]`的时候，就相当于`dp[3] = dp[3] + dp[1]`,即本来有多少种方法，加上去掉了2以后有多少种方法。因为以前没有考虑过2,现在知道，只要整到了1,就一定可以整到3。
