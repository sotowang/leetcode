# [排序链表](https://leetcode-cn.com/problems/sort-list/)

在` O(nlogn) `时间复杂度和常数级空间复杂度下，对链表进行排序。

**示例** 1:

```
输入: 4->2->1->3
输出: 1->2->3->4
```

**示例** 2:

```
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

---

 https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/ 

## 归并排序（从底至顶直接合并）

* 对于非递归的归并排序，需要使用迭代的方式替换cut环节：
  * 我们知道，`cut`环节本质上是通过二分法得到链表最小节点单元，再通过多轮合并得到排序结果。
  
  * 每一轮合并merge操作针对的单元都有固定长度`intv`，例如：
    * 第一轮合并时`intv = 1`，即将整个链表切分为多个长度为1的单元，并按顺序两两排序合并，合并完成的已排序单元长度为2。
    * 第二轮合并时`intv = 2`，即将整个链表切分为多个长度为2的单元，并按顺序两两排序合并，合并完成已排序单元长度为4。
    * 以此类推，直到单元长度`intv >= 链表长度`，代表已经排序完成。
    
  * 根据以上推论，我们可以仅根据`intv`计算每个单元边界，并完成链表的每轮排序合并，例如:
      
      * 当`intv = 1`时，将链表第`1`和第`2`节点排序合并，第`3`和第`4`节点排序合并，……。
      * 当`intv = 2`时，将链表第`1-2`和第`3-4`节点排序合并，第`5-6`和第`7-8`节点排序合并，……。
      * 当`intv = 4`时，将链表第`1-4`和第`5-8`节点排序合并，第`9-12`和第`13-16`节点排序合并，……。
      
  * 此方法时间复杂度`O(nlogn)`，空间复杂度`O(1)`。
  
      ![Picture1.png](https://pic.leetcode-cn.com/c1d5347aa56648afdec22372ee0ed13cf4c25347bd2bb9727b09327ce04360c2-Picture1.png)

* 模拟上述的多轮排序合并：
  * 统计链表长度`length`，用于通过判断`intv < length`判定是否完成排序；
  * 额外声明一个节点`res`，作为头部后面接整个链表，用于：
    `intv *= 2`即切换到下一轮合并时，可通过`res.next`找到链表头部h；
    执行排序合并时，需要一个辅助节点作为头部，而`res`则作为链表头部排序合并时的辅助头部`pre`；后面的合并排序可以将上次合并排序的尾部tail用做辅助节点。
  * 在每轮`intv`下的合并流程：
    * 根据`intv`找到合并单元1和单元2的头部`h1`,` h2`。由于链表长度可能不是2^n，需要考虑边界条件：
      * 在找`h2`过程中，如果链表剩余元素个数少于`intv`，则无需合并环节，直接`break`，执行下一轮合并；
      * 若`h2`存在，但以`h2`为头部的剩余元素个数少于`intv`，也执行合并环节，`h2`单元的长度为`c2 = intv - i`。
    * 合并长度为`c1`, `c2`的`h1`, `h2`链表，其中：
      * 合并完后，需要修改新的合并单元的尾部`pre`指针指向下一个合并单元头部h。（在寻找`h1`, `h2`环节中，h指针已经被移动到下一个单元头部）
      * 合并单元尾部同时也作为下次合并的辅助头部`pre`。
    * 当`h == None`，代表此轮`intv`合并完成，跳出。
  * 每轮合并完成后将单元长度×2，切换到下轮合并：`intv *= 2`。

