# [通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)

 给定一个字符串 (`s`) 和一个字符模式 (`p`) ，实现一个支持 `'?'` 和 `'*'` 的通配符匹配。 

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```

 两个字符串**完全匹配**才算匹配成功。 

 **说明:** 

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `?` 和 `*`。

 **示例 1:** 

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

 **示例 2:** 

```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```

**示例 3:**

```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```

 **示例 4:** 

```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".

```

 **示例 5:** 

```
输入:
s = "acdcb"
p = "a*c?b"
输入: false
```

---

 https://leetcode-cn.com/problems/wildcard-matching/solution/dong-tai-gui-hua-si-yao-su-by-a380922457-4/ 

（一）状态

* `f[i][j]`表示`s1`的前i个字符，和`s2`的前j个字符，能否匹配

（二）转移方程

* 如果`s1`的第` i` 个字符和`s2`的第 `j` 个字符相同，或者`s2`的第 `j `个字符为 `“.”`
* `f[i][j] `= `f[i - 1][j - 1]`
  如果`s2`的第 `j` 个字符为 *
  * 若`s2`的第 `j` 个字符匹配空串, `f[i][j] = f[i][j - 1]`
  * 若`s2`的第 `j `个字符匹配`s1`的第` i `个字符, `f[i][j] = f[i - 1`][j]
  * 这里注意不是` f[i - 1][j - 1]`， 举个例子就明白了 `(abc, a*) f[3][2] = f[2`][2]

（三）初始化

* `f[0][i] = f[0][i - 1] && s2[i] == *`
* 即`s1`的前0个字符和`s2`的前i个字符能否匹配

（四）结果

* `f[m][n]`